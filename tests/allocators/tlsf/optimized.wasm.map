{"version":3,"sources":["~lib/internal/allocator.ts","~lib/allocator/tlsf.ts","~lib/memory.ts"],"names":[],"mappings":"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","sourceRoot":"assemblyscript:///","sourceContents":["/** Number of alignment bits. */\r\nexport const AL_BITS: u32 = 3;\r\n\r\n/** Number of possible alignment values. */\r\nexport const AL_SIZE: usize = 1 << <usize>AL_BITS;\r\n\r\n/** Mask to obtain just the alignment bits. */\r\nexport const AL_MASK: usize = AL_SIZE - 1;\r\n\r\n/** Maximum 32-bit allocation size. */\r\nexport const MAX_SIZE_32: usize = 1 << 30; // 1GB\r\n","/**\r\n * Two-Level Segregate Fit Memory Allocator.\r\n *\r\n * A general purpose dynamic memory allocator specifically designed to meet real-time requirements.\r\n * Always aligns to 8 bytes.\r\n *\r\n * @module std/assembly/allocator/tlsf\r\n *//***/\r\n\r\n// ╒══════════════ Block size interpretation (32-bit) ═════════════╕\r\n//    3                   2                   1\r\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\r\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┴─┴─┴─┴─╫─┴─┴─┤\r\n// │ |                    FL                       │ SB = SL + AL  │ ◄─ usize\r\n// └───────────────────────────────────────────────┴─────────╨─────┘\r\n// FL: first level, SL: second level, AL: alignment, SB: small block\r\n\r\nimport {\r\n  AL_BITS,\r\n  AL_SIZE,\r\n  AL_MASK\r\n} from \"../internal/allocator\";\r\n\r\nconst SL_BITS: u32 = 5;\r\nconst SL_SIZE: usize = 1 << <usize>SL_BITS;\r\n\r\nconst SB_BITS: usize = <usize>(SL_BITS + AL_BITS);\r\nconst SB_SIZE: usize = 1 << <usize>SB_BITS;\r\n\r\nconst FL_BITS: u32 = (sizeof<usize>() == sizeof<u32>()\r\n  ? 30 // ^= up to 1GB per block\r\n  : 32 // ^= up to 4GB per block\r\n) - SB_BITS;\r\n\r\n// ╒════════════════ Block structure layout (32-bit) ══════════════╕\r\n//    3                   2                   1\r\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\r\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┼─┤\r\n// │                          size                             │L│F│ ◄─┐ info\r\n// ╞═══════════════════════════════════════════════════════════╧═╧═╡   │      ┐\r\n// │                        if free: ◄ prev                        │ ◄─┤ usize\r\n// ├───────────────────────────────────────────────────────────────┤   │\r\n// │                        if free: next ►                        │ ◄─┤\r\n// ├───────────────────────────────────────────────────────────────┤   │\r\n// │                ... unused free space >= 0 ...                 │   │    = 0\r\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤   │\r\n// │                        if free: jump ▲                        │ ◄─┘\r\n// └───────────────────────────────────────────────────────────────┘ MIN SIZE ┘\r\n// F: FREE, L: LEFT_FREE\r\n\r\n/** Tag indicating that this block is free. */\r\nconst FREE: usize = 1 << 0;\r\n/** Tag indicating that this block's left block is free. */\r\nconst LEFT_FREE: usize = 1 << 1;\r\n/** Mask to obtain all tags. */\r\nconst TAGS: usize = FREE | LEFT_FREE;\r\n\r\n/** Block structure. */\r\n@unmanaged\r\nclass Block {\r\n\r\n  /** Info field holding this block's size and tags. */\r\n  info: usize;\r\n\r\n  /** End offset of the {@link Block#info} field. User data starts here. */\r\n  static readonly INFO: usize = (sizeof<usize>() + AL_MASK) & ~AL_MASK;\r\n\r\n  /** Previous free block, if any. Only valid if free. */\r\n  prev: Block | null;\r\n  /** Next free block, if any. Only valid if free. */\r\n  next: Block | null;\r\n\r\n  /** Minimum size of a block, excluding {@link Block#info}. */\r\n  static readonly MIN_SIZE: usize = (3 * sizeof<usize>() + AL_MASK) & ~AL_MASK;// prev + next + jump\r\n\r\n  /** Maximum size of a used block, excluding {@link Block#info}. */\r\n  static readonly MAX_SIZE: usize = 1 << (FL_BITS + SB_BITS);\r\n\r\n  /** Gets this block's left (free) block in memory. */\r\n  get left(): Block {\r\n    assert(this.info & LEFT_FREE); // must be free to contain a jump\r\n    return assert(\r\n      load<Block>(changetype<usize>(this) - sizeof<usize>())\r\n    ); // can't be null\r\n  }\r\n\r\n  /** Gets this block's right block in memory. */\r\n  get right(): Block {\r\n    assert(this.info & ~TAGS); // can't skip beyond the tail block\r\n    return assert(\r\n      changetype<Block>(\r\n        changetype<usize>(this) + Block.INFO + (this.info & ~TAGS)\r\n      )\r\n    ); // can't be null\r\n  }\r\n}\r\n\r\n// ╒════════════════ Root structure layout (32-bit) ═══════════════╕\r\n//    3                   2                   1\r\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\r\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤          ┐\r\n// │        0        |           flMap                            S│ ◄────┐\r\n// ╞═══════════════════════════════════════════════════════════════╡      │\r\n// │                           slMap[0] S                          │ ◄─┐  │\r\n// ├───────────────────────────────────────────────────────────────┤   │  │\r\n// │                           slMap[1]                            │ ◄─┤  │\r\n// ├───────────────────────────────────────────────────────────────┤  u32 │\r\n// │                              ...                              │ ◄─┤  │\r\n// ├───────────────────────────────────────────────────────────────┤   │  │\r\n// │                           slMap[22] P                         │ ◄─┘  │\r\n// ╞═══════════════════════════════════════════════════════════════╡    usize\r\n// │                            head[0]                            │ ◄────┤\r\n// ├───────────────────────────────────────────────────────────────┤      │\r\n// │                              ...                              │ ◄────┤\r\n// ├───────────────────────────────────────────────────────────────┤      │\r\n// │                           head[736]                           │ ◄────┤\r\n// ╞═══════════════════════════════════════════════════════════════╡      │\r\n// │                            tailRef                            │ ◄────┘\r\n// └───────────────────────────────────────────────────────────────┘   SIZE   ┘\r\n// S: Small blocks map, P: Possibly padded if 64-bit\r\n\r\nassert((1 << SL_BITS) <= 32); // second level must fit into 32 bits\r\n\r\n/** Root structure. */\r\n@unmanaged\r\nclass Root {\r\n\r\n  /** First level bitmap. */\r\n  flMap: usize = 0;\r\n\r\n  /** Start offset of second level maps. */\r\n  private static readonly SL_START: usize = sizeof<usize>();\r\n\r\n  // Using *one* SL map per *FL bit*\r\n\r\n  /** Gets the second level map for the specified first level. */\r\n  getSLMap(fl: usize): u32 {\r\n    assert(fl < FL_BITS); // fl out of range\r\n    return load<u32>(changetype<usize>(this) + fl * 4, Root.SL_START);\r\n  }\r\n\r\n  /** Sets the second level map for the specified first level. */\r\n  setSLMap(fl: usize, value: u32): void {\r\n    assert(fl < FL_BITS); // fl out of range\r\n    store<u32>(changetype<usize>(this) + fl * 4, value, Root.SL_START);\r\n  }\r\n\r\n  /** End offset of second level maps. */\r\n  private static readonly SL_END: usize = Root.SL_START + FL_BITS * 4;\r\n\r\n  // Using *number bits per SL* heads per *FL bit*\r\n\r\n  /** Start offset of FL/SL heads. */\r\n  private static readonly HL_START: usize = (Root.SL_END + AL_MASK) & ~AL_MASK;\r\n\r\n  /** Gets the head of the specified first and second level index. */\r\n  getHead(fl: usize, sl: u32): Block | null {\r\n    assert(fl < FL_BITS); // fl out of range\r\n    assert(sl < SL_SIZE); // sl out of range\r\n    return changetype<Block>(load<usize>(\r\n      changetype<usize>(this) + (fl * SL_SIZE + <usize>sl) * sizeof<usize>()\r\n    , Root.HL_START));\r\n  }\r\n\r\n  /** Sets the head of the specified first and second level index. */\r\n  setHead(fl: usize, sl: u32, value: Block | null): void {\r\n    assert(fl < FL_BITS); // fl out of range\r\n    assert(sl < SL_SIZE); // sl out of range\r\n    store<usize>(\r\n      changetype<usize>(this) + (fl * SL_SIZE + <usize>sl) * sizeof<usize>()\r\n    , changetype<usize>(value)\r\n    , Root.HL_START);\r\n  }\r\n\r\n  /** End offset of FL/SL heads. */\r\n  private static readonly HL_END: usize = (\r\n    Root.HL_START + FL_BITS * SL_SIZE * sizeof<usize>()\r\n  );\r\n\r\n  get tailRef(): usize { return load<usize>(0, Root.HL_END); }\r\n  set tailRef(value: usize) { store<usize>(0, value, Root.HL_END); }\r\n\r\n  /** Total size of the {@link Root} structure. */\r\n  static readonly SIZE: usize = Root.HL_END + sizeof<usize>();\r\n\r\n  /** Inserts a previously used block back into the free list. */\r\n  insert(block: Block): void {\r\n    // check as much as possible here to prevent invalid free blocks\r\n    assert(block); // cannot be null\r\n    var blockInfo = block.info;\r\n    assert(blockInfo & FREE); // must be free\r\n    var size: usize;\r\n    assert(\r\n      (size = block.info & ~TAGS) >= Block.MIN_SIZE && size < Block.MAX_SIZE\r\n    ); // must be valid, not necessary to compute yet if noAssert=true\r\n\r\n    var right: Block = assert(block.right); // can't be null\r\n    var rightInfo = right.info;\r\n\r\n    // merge with right block if also free\r\n    if (rightInfo & FREE) {\r\n      this.remove(right);\r\n      block.info = (blockInfo += Block.INFO + (rightInfo & ~TAGS));\r\n      right = block.right;\r\n      rightInfo = right.info;\r\n      // jump is set below\r\n    }\r\n\r\n    // merge with left block if also free\r\n    if (blockInfo & LEFT_FREE) {\r\n      let left: Block = assert(block.left); // can't be null\r\n      let leftInfo = left.info;\r\n      assert(leftInfo & FREE); // must be free according to tags\r\n      this.remove(left);\r\n      left.info = (leftInfo += Block.INFO + (blockInfo & ~TAGS));\r\n      block = left;\r\n      blockInfo = leftInfo;\r\n      // jump is set below\r\n    }\r\n\r\n    right.info = rightInfo | LEFT_FREE;\r\n    this.setJump(block, right);\r\n    // right is no longer used now, hence rightInfo is not synced\r\n\r\n    size = blockInfo & ~TAGS;\r\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE); // must be valid\r\n\r\n    // mapping_insert\r\n    var fl: usize, sl: u32;\r\n    if (size < SB_SIZE) {\r\n      fl = 0;\r\n      sl = <u32>(size / AL_SIZE);\r\n    } else {\r\n      fl = fls<usize>(size);\r\n      sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\r\n      fl -= SB_BITS - 1;\r\n    }\r\n\r\n    // perform insertion\r\n    var head = this.getHead(fl, sl);\r\n    block.prev = null;\r\n    block.next = head;\r\n    if (head) head.prev = block;\r\n    this.setHead(fl, sl, block);\r\n\r\n    // update first and second level maps\r\n    this.flMap |= (1 << fl);\r\n    this.setSLMap(fl, this.getSLMap(fl) | (1 << sl));\r\n  }\r\n\r\n  /**\r\n   * Removes a free block from FL/SL maps. Does not alter left/jump because it\r\n   * is likely that splitting is performed afterwards, invalidating any changes\r\n   * again.\r\n   */\r\n  private remove(block: Block): void {\r\n    var blockInfo = block.info;\r\n    assert(blockInfo & FREE); // must be free\r\n    var size = blockInfo & ~TAGS;\r\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE); // must be valid\r\n\r\n    // mapping_insert\r\n    var fl: usize, sl: u32;\r\n    if (size < SB_SIZE) {\r\n      fl = 0;\r\n      sl = <u32>(size / AL_SIZE);\r\n    } else {\r\n      fl = fls<usize>(size);\r\n      sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\r\n      fl -= SB_BITS - 1;\r\n    }\r\n\r\n    // link previous and next free block\r\n    var prev = block.prev;\r\n    var next = block.next;\r\n    if (prev) prev.next = next;\r\n    if (next) next.prev = prev;\r\n\r\n    // update head if we are removing it\r\n    if (block == this.getHead(fl, sl)) {\r\n      this.setHead(fl, sl, next);\r\n\r\n      // clear second level map if head is empty now\r\n      if (!next) {\r\n        let slMap = this.getSLMap(fl);\r\n        this.setSLMap(fl, slMap &= ~(1 << sl));\r\n\r\n        // clear first level map if second level is empty now\r\n        if (!slMap) this.flMap &= ~(1 << fl);\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Searches for a free block of at least the specified size. */\r\n  search(size: usize): Block | null {\r\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE);\r\n\r\n    // mapping_search\r\n    var fl: usize, sl: u32;\r\n    if (size < SB_SIZE) {\r\n      fl = 0;\r\n      sl = <u32>(size / AL_SIZE);\r\n    } else {\r\n      // (*) size += (1 << (fls<usize>(size) - SL_BITS)) - 1;\r\n      fl = fls<usize>(size);\r\n      sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\r\n      fl -= SB_BITS - 1;\r\n      // (*) instead of rounding up, use next second level list for better fit\r\n      if (sl < SL_SIZE - 1) ++sl;\r\n      else ++fl, sl = 0;\r\n    }\r\n\r\n    // search second level\r\n    var slMap = this.getSLMap(fl) & (~0 << sl);\r\n    var head: Block | null;\r\n    if (!slMap) {\r\n      // search next larger first level\r\n      let flMap = this.flMap & (~0 << (fl + 1));\r\n      if (!flMap) {\r\n        head = null;\r\n      } else {\r\n        fl = ffs<usize>(flMap);\r\n        slMap = assert(this.getSLMap(fl)); // can't be zero if fl points here\r\n        head = this.getHead(fl, ffs<u32>(slMap));\r\n      }\r\n    } else {\r\n      head = this.getHead(fl, ffs<u32>(slMap));\r\n    }\r\n    return head;\r\n  }\r\n\r\n  /** Links a free left with its right block in memory. */\r\n  private setJump(left: Block, right: Block): void {\r\n    assert(left.info & FREE);       // must be free\r\n    assert(left.right == right);    // right block must match\r\n    assert(right.info & LEFT_FREE); // right block must be tagged as LEFT_FREE\r\n    store<Block>(\r\n      changetype<usize>(right) - sizeof<usize>()\r\n    , left); // last word in left block's (free) data region\r\n  }\r\n\r\n  /**\r\n   * Uses the specified free block, removing it from internal maps and\r\n   * splitting it if possible, and returns its data pointer.\r\n   */\r\n  use(block: Block, size: usize): usize {\r\n    var blockInfo = block.info;\r\n    assert(blockInfo & FREE); // must be free so we can use it\r\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE); // must be valid\r\n    assert(!(size & AL_MASK)); // size must be aligned so the new block is\r\n\r\n    this.remove(block);\r\n\r\n    // split if the block can hold another MIN_SIZE block\r\n    var remaining = (blockInfo & ~TAGS) - size;\r\n    if (remaining >= Block.INFO + Block.MIN_SIZE) {\r\n      block.info = size | (blockInfo & LEFT_FREE); // also discards FREE\r\n\r\n      let spare = changetype<Block>(\r\n        changetype<usize>(block) + Block.INFO + size\r\n      );\r\n      spare.info = (remaining - Block.INFO) | FREE; // not LEFT_FREE\r\n      this.insert(spare); // also sets jump\r\n\r\n    // otherwise tag block as no longer FREE and right as no longer LEFT_FREE\r\n    } else {\r\n      block.info = blockInfo & ~FREE;\r\n      let right: Block = assert(block.right); // can't be null (tail)\r\n      right.info &= ~LEFT_FREE;\r\n    }\r\n\r\n    return changetype<usize>(block) + Block.INFO;\r\n  }\r\n\r\n  /** Adds more memory to the pool. */\r\n  addMemory(start: usize, end: usize): bool {\r\n    assert(start <= end);\r\n    assert(!(start & AL_MASK)); // must be aligned\r\n    assert(!(end & AL_MASK)); // must be aligned\r\n\r\n    var tailRef = this.tailRef;\r\n    var tailInfo: usize = 0;\r\n    if (tailRef) {\r\n      assert(start >= tailRef + sizeof<usize>()); // starts after tail\r\n\r\n      // merge with current tail if adjacent\r\n      if (start - Block.INFO == tailRef) {\r\n        start -= Block.INFO;\r\n        tailInfo = changetype<Block>(tailRef).info;\r\n      }\r\n\r\n    } else {\r\n      assert(start >= changetype<usize>(this) + Root.SIZE); // starts after root\r\n    }\r\n\r\n    // check if size is large enough for a free block and the tail block\r\n    var size = end - start;\r\n    if (size < Block.INFO + Block.MIN_SIZE + Block.INFO) {\r\n      return false;\r\n    }\r\n\r\n    // left size is total minus its own and the zero-length tail's header\r\n    var leftSize = size - 2 * Block.INFO;\r\n    var left = changetype<Block>(start);\r\n    left.info = leftSize | FREE | (tailInfo & LEFT_FREE);\r\n    left.prev = null;\r\n    left.next = null;\r\n\r\n    // tail is a zero-length used block\r\n    var tail = changetype<Block>(start + size - Block.INFO);\r\n    tail.info = 0 | LEFT_FREE;\r\n    this.tailRef = changetype<usize>(tail);\r\n\r\n    this.insert(left); // also merges with free left before tail / sets jump\r\n\r\n    return true;\r\n  }\r\n}\r\n\r\n/** Determines the first (LSB to MSB) set bit's index of a word. */\r\nfunction ffs<T>(word: T): T {\r\n  assert(word != 0); // word cannot be 0\r\n  return ctz<T>(word);  // differs from ffs only for 0\r\n}\r\n\r\n/** Determines the last (LSB to MSB) set bit's index of a word. */\r\nfunction fls<T>(word: T): T {\r\n  assert(word != 0); // word cannot be 0\r\n  const inv: T = (sizeof<T>() << 3) - 1;\r\n  return inv - clz<T>(word);\r\n}\r\n\r\n/** Reference to the initialized {@link Root} structure, once initialized. */\r\nvar ROOT: Root = changetype<Root>(0);\r\n\r\n// External interface\r\n\r\n/** Allocates a chunk of memory. */\r\n@global\r\nexport function __memory_allocate(size: usize): usize {\r\n\r\n  // initialize if necessary\r\n  var root = ROOT;\r\n  if (!root) {\r\n    let rootOffset = (HEAP_BASE + AL_MASK) & ~AL_MASK;\r\n    let pagesBefore = memory.size();\r\n    let pagesNeeded = <i32>((((rootOffset + Root.SIZE) + 0xffff) & ~0xffff) >>> 16);\r\n    if (pagesNeeded > pagesBefore && memory.grow(pagesNeeded - pagesBefore) < 0) unreachable();\r\n    ROOT = root = changetype<Root>(rootOffset);\r\n    root.tailRef = 0;\r\n    root.flMap = 0;\r\n    for (let fl: usize = 0; fl < FL_BITS; ++fl) {\r\n      root.setSLMap(fl, 0);\r\n      for (let sl: u32 = 0; sl < SL_SIZE; ++sl) {\r\n        root.setHead(fl, sl, null);\r\n      }\r\n    }\r\n    root.addMemory((rootOffset + Root.SIZE + AL_MASK) & ~AL_MASK, memory.size() << 16);\r\n  }\r\n\r\n  // search for a suitable block\r\n  var data: usize = 0;\r\n  if (size) {\r\n    if (size > Block.MAX_SIZE) unreachable();\r\n    // 32-bit MAX_SIZE is 1 << 30 and itself aligned, hence the following can't overflow MAX_SIZE\r\n    size = max<usize>((size + AL_MASK) & ~AL_MASK, Block.MIN_SIZE);\r\n\r\n    let block = root.search(size);\r\n    if (!block) {\r\n\r\n      // request more memory\r\n      let pagesBefore = memory.size();\r\n      let pagesNeeded = <i32>(((size + 0xffff) & ~0xffff) >>> 16);\r\n      let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\r\n      if (memory.grow(pagesWanted) < 0) {\r\n        if (memory.grow(pagesNeeded) < 0) {\r\n          unreachable(); // out of memory\r\n        }\r\n      }\r\n      let pagesAfter = memory.size();\r\n      root.addMemory(<usize>pagesBefore << 16, <usize>pagesAfter << 16);\r\n      block = assert(root.search(size)); // must be found now\r\n    }\r\n\r\n    assert((block.info & ~TAGS) >= size);\r\n    data = root.use(<Block>block, size);\r\n  }\r\n\r\n  return data;\r\n}\r\n\r\n/** Frees the chunk of memory at the specified address. */\r\n@global\r\nexport function __memory_free(data: usize): void {\r\n  if (data) {\r\n    let root = ROOT;\r\n    if (root) {\r\n      let block = changetype<Block>(data - Block.INFO);\r\n      let blockInfo = block.info;\r\n      assert(!(blockInfo & FREE)); // must be used\r\n      block.info = blockInfo | FREE;\r\n      root.insert(changetype<Block>(data - Block.INFO));\r\n    }\r\n  }\r\n}\r\n\r\n@global\r\nexport function __memory_reset(): void {\r\n  unreachable();\r\n}\r\n","export namespace memory {\r\n\r\n  @builtin\r\n  export declare function size(): i32;\r\n\r\n  @builtin\r\n  export declare function grow(pages: i32): i32;\r\n\r\n  export function fill(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\r\n    if (isDefined(__memory_fill)) { __memory_fill(dest, c, n); return; } // tslint:disable-line\r\n    memset(dest, c, n);\r\n  }\r\n\r\n  export function copy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\r\n    if (isDefined(__memory_copy)) { __memory_copy(dest, src, n); return; } // tslint:disable-line\r\n    memmove(dest, src, n);\r\n  }\r\n\r\n  export function compare(vl: usize, vr: usize, n: usize): i32 { // see: musl/src/string/memcmp.c\r\n    if (isDefined(__memory_compare)) return __memory_compare(vl, vr, n); // tslint:disable-line\r\n    return memcmp(vl, vr, n);\r\n  }\r\n\r\n  // Passive segments\r\n\r\n  // export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\r\n  //   __memory_init(segmentIndex, srcOffset, dstOffset);\r\n  // }\r\n\r\n  // export function drop(segmentIndex: u32): void {\r\n  //   __memory_drop(segmentIndex);\r\n  // }\r\n\r\n  // Allocator\r\n\r\n  export function allocate(size: usize): usize {\r\n    if (isDefined(__memory_allocate)) return __memory_allocate(size); // tslint:disable-line\r\n    WARNING(\"Calling 'memory.allocate' requires a memory manager to be present.\");\r\n    return <usize>unreachable();\r\n  }\r\n\r\n  export function free(ptr: usize): void {\r\n    if (isDefined(__memory_free)) { __memory_free(ptr); return; } // tslint:disable-line\r\n    WARNING(\"Calling 'memory.free' requires a memory manager to be present.\");\r\n    unreachable();\r\n  }\r\n\r\n  export function reset(): void {\r\n    if (isDefined(__memory_reset)) { __memory_reset(); return; } // tslint:disable-line\r\n    unreachable();\r\n  }\r\n}\r\n\r\n// this function will go away once `memory.copy` becomes an intrinsic\r\nfunction memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\r\n  var w: u32, x: u32;\r\n\r\n  // copy 1 byte each until src is aligned to 4 bytes\r\n  while (n && (src & 3)) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    n--;\r\n  }\r\n\r\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\r\n  if ((dest & 3) == 0) {\r\n    while (n >= 16) {\r\n      store<u32>(dest     , load<u32>(src     ));\r\n      store<u32>(dest +  4, load<u32>(src +  4));\r\n      store<u32>(dest +  8, load<u32>(src +  8));\r\n      store<u32>(dest + 12, load<u32>(src + 12));\r\n      src += 16; dest += 16; n -= 16;\r\n    }\r\n    if (n & 8) {\r\n      store<u32>(dest    , load<u32>(src    ));\r\n      store<u32>(dest + 4, load<u32>(src + 4));\r\n      dest += 8; src += 8;\r\n    }\r\n    if (n & 4) {\r\n      store<u32>(dest, load<u32>(src));\r\n      dest += 4; src += 4;\r\n    }\r\n    if (n & 2) { // drop to 2 bytes each\r\n      store<u16>(dest, load<u16>(src));\r\n      dest += 2; src += 2;\r\n    }\r\n    if (n & 1) { // drop to 1 byte\r\n      store<u8>(dest++, load<u8>(src++));\r\n    }\r\n    return;\r\n  }\r\n\r\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\r\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\r\n  if (n >= 32) {\r\n    switch (dest & 3) {\r\n      // known to be != 0\r\n      case 1: {\r\n        w = load<u32>(src);\r\n        store<u8>(dest++, load<u8>(src++));\r\n        store<u8>(dest++, load<u8>(src++));\r\n        store<u8>(dest++, load<u8>(src++));\r\n        n -= 3;\r\n        while (n >= 17) {\r\n          x = load<u32>(src + 1);\r\n          store<u32>(dest, w >> 24 | x << 8);\r\n          w = load<u32>(src + 5);\r\n          store<u32>(dest + 4, x >> 24 | w << 8);\r\n          x = load<u32>(src + 9);\r\n          store<u32>(dest + 8, w >> 24 | x << 8);\r\n          w = load<u32>(src + 13);\r\n          store<u32>(dest + 12, x >> 24 | w << 8);\r\n          src += 16; dest += 16; n -= 16;\r\n        }\r\n        break;\r\n      }\r\n      case 2: {\r\n        w = load<u32>(src);\r\n        store<u8>(dest++, load<u8>(src++));\r\n        store<u8>(dest++, load<u8>(src++));\r\n        n -= 2;\r\n        while (n >= 18) {\r\n          x = load<u32>(src + 2);\r\n          store<u32>(dest, w >> 16 | x << 16);\r\n          w = load<u32>(src + 6);\r\n          store<u32>(dest + 4, x >> 16 | w << 16);\r\n          x = load<u32>(src + 10);\r\n          store<u32>(dest + 8, w >> 16 | x << 16);\r\n          w = load<u32>(src + 14);\r\n          store<u32>(dest + 12, x >> 16 | w << 16);\r\n          src += 16; dest += 16; n -= 16;\r\n        }\r\n        break;\r\n      }\r\n      case 3: {\r\n        w = load<u32>(src);\r\n        store<u8>(dest++, load<u8>(src++));\r\n        n -= 1;\r\n        while (n >= 19) {\r\n          x = load<u32>(src + 3);\r\n          store<u32>(dest, w >> 8 | x << 24);\r\n          w = load<u32>(src + 7);\r\n          store<u32>(dest + 4, x >> 8 | w << 24);\r\n          x = load<u32>(src + 11);\r\n          store<u32>(dest + 8, w >> 8 | x << 24);\r\n          w = load<u32>(src + 15);\r\n          store<u32>(dest + 12, x >> 8 | w << 24);\r\n          src += 16; dest += 16; n -= 16;\r\n        }\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  // copy remaining bytes one by one\r\n  if (n & 16) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n  if (n & 8) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n  if (n & 4) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n  if (n & 2) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n  if (n & 1) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n}\r\n\r\n// this function will go away once `memory.copy` becomes an intrinsic\r\nfunction memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\r\n  if (dest == src) return;\r\n  if (src + n <= dest || dest + n <= src) {\r\n    memcpy(dest, src, n);\r\n    return;\r\n  }\r\n  if (dest < src) {\r\n    if ((src & 7) == (dest & 7)) {\r\n      while (dest & 7) {\r\n        if (!n) return;\r\n        --n;\r\n        store<u8>(dest++, load<u8>(src++));\r\n      }\r\n      while (n >= 8) {\r\n        store<u64>(dest, load<u64>(src));\r\n        n    -= 8;\r\n        dest += 8;\r\n        src  += 8;\r\n      }\r\n    }\r\n    while (n) {\r\n      store<u8>(dest++, load<u8>(src++));\r\n      --n;\r\n    }\r\n  } else {\r\n    if ((src & 7) == (dest & 7)) {\r\n      while ((dest + n) & 7) {\r\n        if (!n) return;\r\n        store<u8>(dest + --n, load<u8>(src + n));\r\n      }\r\n      while (n >= 8) {\r\n        n -= 8;\r\n        store<u64>(dest + n, load<u64>(src + n));\r\n      }\r\n    }\r\n    while (n) {\r\n      store<u8>(dest + --n, load<u8>(src + n));\r\n    }\r\n  }\r\n}\r\n\r\n// this function will go away once `memory.fill` becomes an intrinsic\r\nfunction memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\r\n\r\n  // fill head and tail with minimal branching\r\n  if (!n) return;\r\n  store<u8>(dest, c);\r\n  store<u8>(dest + n - 1, c);\r\n  if (n <= 2) return;\r\n\r\n  store<u8>(dest + 1, c);\r\n  store<u8>(dest + 2, c);\r\n  store<u8>(dest + n - 2, c);\r\n  store<u8>(dest + n - 3, c);\r\n  if (n <= 6) return;\r\n  store<u8>(dest + 3, c);\r\n  store<u8>(dest + n - 4, c);\r\n  if (n <= 8) return;\r\n\r\n  // advance pointer to align it at 4-byte boundary\r\n  var k: usize = -dest & 3;\r\n  dest += k;\r\n  n -= k;\r\n  n &= -4;\r\n\r\n  var c32: u32 = <u32>-1 / 255 * c;\r\n\r\n  // fill head/tail up to 28 bytes each in preparation\r\n  store<u32>(dest, c32);\r\n  store<u32>(dest + n - 4, c32);\r\n  if (n <= 8) return;\r\n  store<u32>(dest + 4, c32);\r\n  store<u32>(dest + 8, c32);\r\n  store<u32>(dest + n - 12, c32);\r\n  store<u32>(dest + n - 8, c32);\r\n  if (n <= 24) return;\r\n  store<u32>(dest + 12, c32);\r\n  store<u32>(dest + 16, c32);\r\n  store<u32>(dest + 20, c32);\r\n  store<u32>(dest + 24, c32);\r\n  store<u32>(dest + n - 28, c32);\r\n  store<u32>(dest + n - 24, c32);\r\n  store<u32>(dest + n - 20, c32);\r\n  store<u32>(dest + n - 16, c32);\r\n\r\n  // align to a multiple of 8\r\n  k = 24 + (dest & 4);\r\n  dest += k;\r\n  n -= k;\r\n\r\n  // copy 32 bytes each\r\n  var c64: u64 = <u64>c32 | (<u64>c32 << 32);\r\n  while (n >= 32) {\r\n    store<u64>(dest, c64);\r\n    store<u64>(dest + 8, c64);\r\n    store<u64>(dest + 16, c64);\r\n    store<u64>(dest + 24, c64);\r\n    n -= 32;\r\n    dest += 32;\r\n  }\r\n}\r\n\r\nfunction memcmp(vl: usize, vr: usize, n: usize): i32 { // see: musl/src/string/memcmp.c\r\n  if (vl == vr) return 0;\r\n  while (n != 0 && load<u8>(vl) == load<u8>(vr)) {\r\n    n--; vl++; vr++;\r\n  }\r\n  return n ? <i32>load<u8>(vl) - <i32>load<u8>(vr) : 0;\r\n}\r\n"]}